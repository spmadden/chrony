diff -urN s03/client.c s04/client.c
--- s03/client.c	2010-02-04 13:07:19.000000000 +0100
+++ s04/client.c	2015-04-10 21:57:00.000000000 +0200
@@ -1272,7 +1272,8 @@
         read_length = recvfrom_status;
         expected_length = PKL_ReplyLength(reply);
 
-        bad_length = (read_length != expected_length);
+        bad_length = (read_length < expected_length ||
+                      expected_length < offsetof(CMD_Reply, data));
         bad_sender = (where_from.u.sa_family != his_addr.u.sa_family ||
                       (where_from.u.sa_family == AF_INET &&
                        (where_from.in4.sin_addr.s_addr != his_addr.in4.sin_addr.s_addr ||
diff -urN s03/cmdmon.c s04/cmdmon.c
--- s03/cmdmon.c	2010-02-04 13:07:19.000000000 +0100
+++ s04/cmdmon.c	2015-04-10 21:57:00.000000000 +0200
@@ -1507,9 +1507,11 @@
         break;
       case CLG_BADSUBNET:
         tx_message->status = htons(STT_BADSUBNET);
+        tx_message->data.subnets_accessed.n_subnets = htonl(0);
         return;
       case CLG_INACTIVE:
         tx_message->status = htons(STT_INACTIVE);
+        tx_message->data.subnets_accessed.n_subnets = htonl(0);
         return;
       default:
         CROAK("Impossible");
@@ -1566,6 +1568,7 @@
         break;
       case CLG_INACTIVE:
         tx_message->status = htons(STT_INACTIVE);
+        tx_message->data.client_accesses.n_clients = htonl(0);
         return;
       default:
         CROAK("Impossible");
@@ -1759,28 +1762,10 @@
   }
 
   read_length = status;
-  expected_length = PKL_CommandLength(&rx_message);
 
   LCL_ReadRawTime(&now);
   LCL_ReadCookedTime(&cooked_now, &local_clock_err);
 
-  tx_message.version = PROTO_VERSION_NUMBER;
-  tx_message.pkt_type = PKT_TYPE_CMD_REPLY;
-  tx_message.res1 = 0;
-  tx_message.res2 = 0;
-  tx_message.command = rx_message.command;
-  tx_message.sequence = rx_message.sequence;
-  tx_message.reply = htons(RPY_NULL);
-  tx_message.number = htons(1);
-  tx_message.total = htons(1);
-  tx_message.pad1 = 0;
-  tx_message.utoken = htonl(utoken);
-  /* Set this to a default (invalid) value.  This protects against the
-     token field being set to an arbitrary value if we reject the
-     message, e.g. due to the host failing the access check. */
-  tx_message.token = htonl(0xffffffffUL);
-  memset(&tx_message.auth, 0, sizeof(tx_message.auth));
-
   switch (where_from.u.sa_family) {
     case AF_INET:
       remote_ip.family = IPADDR_INET4;
@@ -1807,7 +1792,14 @@
 
   allowed = ADF_IsAllowed(access_auth_table, &remote_ip) || localhost;
 
-  if (read_length < offsetof(CMD_Request, data) ||
+  /* Message size sanity check */
+  if (read_length >= offsetof(CMD_Request, data)) {
+    expected_length = PKL_CommandLength(&rx_message);
+  } else {
+    expected_length = 0;
+  }
+
+  if (expected_length < offsetof(CMD_Request, data) ||
       rx_message.pkt_type != PKT_TYPE_CMD_REQUEST ||
       rx_message.res1 != 0 ||
       rx_message.res2 != 0) {
@@ -1819,6 +1811,25 @@
     return;
   }
 
+  rx_command = ntohs(rx_message.command);
+
+  tx_message.version = PROTO_VERSION_NUMBER;
+  tx_message.pkt_type = PKT_TYPE_CMD_REPLY;
+  tx_message.res1 = 0;
+  tx_message.res2 = 0;
+  tx_message.command = rx_message.command;
+  tx_message.sequence = rx_message.sequence;
+  tx_message.reply = htons(RPY_NULL);
+  tx_message.number = htons(1);
+  tx_message.total = htons(1);
+  tx_message.pad1 = 0;
+  tx_message.utoken = htonl(utoken);
+  /* Set this to a default (invalid) value.  This protects against the
+     token field being set to an arbitrary value if we reject the
+     message, e.g. due to the host failing the access check. */
+  tx_message.token = htonl(0xffffffffUL);
+  memset(&tx_message.auth, 0, sizeof(tx_message.auth));
+
   if (rx_message.version != PROTO_VERSION_NUMBER) {
     tx_message.status = htons(STT_NOHOSTACCESS);
     if (!LOG_RateLimited()) {
diff -urN s03/io_linux.h s04/io_linux.h
--- s03/io_linux.h	2010-02-04 13:07:19.000000000 +0100
+++ s04/io_linux.h	2015-04-10 21:57:00.000000000 +0200
@@ -37,7 +37,16 @@
 #define CHRONY_IOC_WRITE        4U
 
 #else
-#error "I don't know the values of the _IOC_* constants for your architecture"
+
+#define CHRONY_IOC_NRBITS       8
+#define CHRONY_IOC_TYPEBITS     8
+#define CHRONY_IOC_SIZEBITS     14
+#define CHRONY_IOC_DIRBITS      2
+
+#define CHRONY_IOC_NONE         0U
+#define CHRONY_IOC_WRITE        1U
+#define CHRONY_IOC_READ         2U
+
 #endif
 
 #define CHRONY_IOC_NRMASK	((1 << CHRONY_IOC_NRBITS)-1)
diff -urN s03/pktlength.c s04/pktlength.c
--- s03/pktlength.c	2010-02-04 13:07:19.000000000 +0100
+++ s04/pktlength.c	2015-04-10 21:57:00.000000000 +0200
@@ -127,6 +127,8 @@
         {
           unsigned long ns;
           ns = ntohl(r->data.subnets_accessed.n_subnets);
+          if (ns > MAX_SUBNETS_ACCESSED)
+            return 0;
           return (offsetof(CMD_Request, data.subnets_accessed.subnets) +
                   ns * sizeof(REQ_SubnetsAccessed_Subnet));
         }
@@ -134,6 +136,8 @@
         {
           unsigned long nc;
           nc = ntohl(r->data.client_accesses.n_clients);
+          if (nc > MAX_CLIENT_ACCESSES)
+            return 0;
           return (offsetof(CMD_Request, data.client_accesses.client_ips) +
                   nc * sizeof(unsigned long));
         }
@@ -189,6 +193,8 @@
         {
           unsigned long ns = ntohl(r->data.subnets_accessed.n_subnets);
           if (r->status == htons(STT_SUCCESS)) {
+            if (ns > MAX_SUBNETS_ACCESSED)
+              return 0;
             return (offsetof(CMD_Reply, data.subnets_accessed.subnets) +
                     ns * sizeof(RPY_SubnetsAccessed_Subnet));
           } else {
@@ -199,6 +205,8 @@
         {
           unsigned long nc = ntohl(r->data.client_accesses.n_clients);
           if (r->status == htons(STT_SUCCESS)) {
+            if (nc > MAX_CLIENT_ACCESSES)
+              return 0;
             return (offsetof(CMD_Reply, data.client_accesses.clients) +
                     nc * sizeof(RPY_ClientAccesses_Client));
           } else {
@@ -209,6 +217,8 @@
         {
           unsigned long nc = ntohl(r->data.client_accesses_by_index.n_clients);
           if (r->status == htons(STT_SUCCESS)) {
+            if (nc > MAX_CLIENT_ACCESSES)
+              return 0;
             return (offsetof(CMD_Reply, data.client_accesses_by_index.clients) +
                     nc * sizeof(RPY_ClientAccesses_Client));
           } else {
@@ -218,6 +228,8 @@
       case RPY_MANUAL_LIST:
         {
           unsigned long ns = ntohl(r->data.manual_list.n_samples);
+          if (ns > MAX_MANUAL_LIST_SAMPLES)
+            return 0;
           if (r->status == htons(STT_SUCCESS)) {
             return (offsetof(CMD_Reply, data.manual_list.samples) +
                     ns * sizeof(RPY_ManualListSample));
diff -urN s03/rtc_linux.c s04/rtc_linux.c
--- s03/rtc_linux.c	2010-02-04 13:07:19.000000000 +0100
+++ s04/rtc_linux.c	2015-04-10 21:57:00.000000000 +0200
@@ -541,63 +541,8 @@
 int
 RTC_Linux_Initialise(void)
 {
-  int major, minor, patch;
   char *direc;
 
-  /* Check whether we can support the real time clock.
-
-     Linux 1.2.x - haven't checked yet
-
-     Linux 1.3.x - don't know, haven't got a system to look at
-
-     Linux 2.0.x - For x<=31, using any variant of the adjtimex() call
-     sets the kernel into a mode where the RTC was updated every 11
-     minutes.  The only way to escape this is to use settimeofday().
-     Since we need to have sole control over the RTC to be able to
-     measure its drift rate, and there is no 'notify' callback to warn
-     you that the kernel is going to do this, I can't see a way to
-     support this.
-
-     Linux 2.0.x - For x>=32 the adjtimex()/RTC behaviour was
-     modified, so that as long as the STA_UNSYNC flag is set the RTC
-     is left alone.  This is the mode we exploit here, so that the RTC
-     continues to go its own sweet way, unless we make updates to it
-     from this module.
-
-     Linux 2.1.x - don't know, haven't got a system to look at.
-
-     Linux 2.2.x, 2.3.x and 2.4.x are believed to be OK for all
-     patch levels
-
-     */
-
-  SYS_Linux_GetKernelVersion(&major, &minor, &patch);
-
-  /* Obviously this test can get more elaborate when we know about
-     more system types. */
-  if (major != 2) {
-    return 0;
-  } else {
-    switch (minor) {
-      case 0:
-        if (patch <= 31) {
-          return 0;
-        }
-        break;
-      case 1:
-        return 0;
-        break;
-      case 2:
-      case 3:
-      case 4:
-      case 5:
-      case 6:
-      case 7:
-      case 8:
-        break; /* OK for all patch levels */
-    } 
-  }
-
   /* Setup details depending on configuration options */
   setup_config();
 
diff -urN s03/sys_linux.c s04/sys_linux.c
--- s03/sys_linux.c	2010-02-04 13:07:19.000000000 +0100
+++ s04/sys_linux.c	2015-04-10 21:57:00.000000000 +0200
@@ -735,7 +735,12 @@
   if (uname(&uts) < 0) {
     LOG_FATAL(LOGF_SysLinux, "Cannot uname(2) to get kernel version, sorry.");
   }
-  if (sscanf(uts.release, "%d.%d.%d", &major, &minor, &patch) != 3) {
+
+  /* default patch level if not defined */
+  patch = 0;
+
+  /* first check about kernel version */
+  if (sscanf(uts.release, "%d.%d.%d", &major, &minor, &patch) < 2) {
     LOG_FATAL(LOGF_SysLinux, "Cannot read information from uname, sorry");
   }
 
@@ -746,30 +751,8 @@
   version_patchlevel = patch;
   
   switch (major) {
-    case 1:
-      /* Does Linux v1.x even support HZ!=100? */
-      switch (minor) {
-        case 2:
-          if (patch == 13) {
-            freq_scale = (hz==100) ? (128.0 / 100.0) : basic_freq_scale ; /* I _think_! */
-	    have_readonly_adjtime = 1;
-          } else {
-            LOG_FATAL(LOGF_SysLinux, "Kernel version not supported yet, sorry.");
-          }
-          break;
-        case 3:
-          /* I guess the change from the 1.2.x scaling to the 2.0.x
-             scaling must have happened during 1.3 development.  I
-             haven't a clue where though, until someone looks it
-             up. */
-          LOG_FATAL(LOGF_SysLinux, "Kernel version not supported yet, sorry.");
-          break;
-        default:
-          LOG_FATAL(LOGF_SysLinux, "Kernel version not supported yet, sorry.");
-          break;
-      }
-      break;
     case 2:
+      /* for kernel 2.x */
       switch (minor) {
         case 0:
           if (patch < 32) {
@@ -807,18 +790,18 @@
             have_readonly_adjtime = 0;
             break;
           }
-          /* Let's be optimistic that these will be the same until proven
-             otherwise :-) */
-        case 7:
-        case 8:
+        default:
           /* These don't need scaling */
           freq_scale = 1.0;
           have_readonly_adjtime = 2;
           break;
-        default:
-          LOG_FATAL(LOGF_SysLinux, "Kernel version not supported yet, sorry.");
       }
       break;
+    case 3:
+      /* for kernel 3.x: These don't need scaling */
+      freq_scale = 1.0;
+      have_readonly_adjtime = 2;
+      break;
     default:
       LOG_FATAL(LOGF_SysLinux, "Kernel's major version not supported yet, sorry");
       break;
@@ -865,16 +848,6 @@
 }
 
 /* ================================================== */
-
-void
-SYS_Linux_GetKernelVersion(int *major, int *minor, int *patchlevel)
-{
-  *major = version_major;
-  *minor = version_minor;
-  *patchlevel = version_patchlevel;
-}
-
-/* ================================================== */
 
 #ifdef FEAT_LINUXCAPS
 void
diff -urN s03/sys_linux.h s04/sys_linux.h
--- s03/sys_linux.h	2010-02-04 13:07:19.000000000 +0100
+++ s04/sys_linux.h	2015-04-10 21:57:00.000000000 +0200
@@ -35,8 +35,6 @@
 
 extern void SYS_Linux_Finalise(void);
 
-extern void SYS_Linux_GetKernelVersion(int *major, int *minor, int *patchlevel);
-
 extern void SYS_Linux_DropRoot(char *user);
 
 extern void SYS_Linux_MemLockAll(int LockAll);
diff -urN s03/version.h s04/version.h
--- s03/version.h	1970-01-01 01:00:00.000000000 +0100
+++ s04/version.h	2015-04-10 21:57:00.000000000 +0200
@@ -0,0 +1,4 @@
+#ifndef VERSION_H
+#define VERSION_H 1
+#define PROGRAM_VERSION_STRING "1.24"
+#endif /* VERSION_H */
